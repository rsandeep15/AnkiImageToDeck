import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import os
from pathlib import Path
import re
from typing import Any, List, Tuple

from openai import OpenAI

from AnkiSync import invoke

BASE_DIR = Path(__file__).resolve().parent
MEDIA_DIR = BASE_DIR / "media"
AUDIO_DIR = MEDIA_DIR / "audio"
AUDIO_DIR.mkdir(parents=True, exist_ok=True)
DEFAULT_MAX_WORKERS = 10
HTML_TAG_RE = re.compile(r"<[^>]+>")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Add text-to-speech audio to Anki notes in a specified deck."
    )
    parser.add_argument(
        "deck",
        help="Name of the Anki deck to process.",
    )
    parser.add_argument(
        "--model",
        default="gpt-4o-mini-tts",
        help=(
            "OpenAI TTS model to use (default: %(default)s). "
            "Consider alternatives like 'gpt-4o-realtime-preview-tts' if available."
        ),
    )
    parser.add_argument(
        "--voice",
        default="onyx",
        help="Voice to use for the TTS model (default: %(default)s).",
    )
    parser.add_argument(
        "--instructions",
        default=(
            "Speak like a native speaker for the passed in language. "
            "Treat the provided text as plain text, ignoring HTML tags or parenthetical notes."
        ),
        help="Additional instructions passed to the TTS model.",
    )
    parser.add_argument(
        "--workers",
        type=int,
        default=int(os.environ.get("ANKI_AUDIO_WORKERS", str(DEFAULT_MAX_WORKERS))),
        help="Maximum number of concurrent audio generations (default: %(default)s).",
    )
    return parser.parse_args()


def load_api_key() -> str:
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        raise SystemExit("Environment variable OPENAI_API_KEY is not set.")
    return api_key


def get_candidate_cards(deckname: str) -> List[Tuple[int, str, str]]:
    cards = invoke("findNotes", query=f"deck:{deckname}")
    if not cards:
        return []
    notes_info = invoke("notesInfo", notes=cards)
    candidates: List[Tuple[int, str, str]] = []
    for card_id, note in zip(cards, notes_info):
        front_text = note["fields"]["Front"]["value"]
        back_text = note["fields"]["Back"]["value"]
        if "[sound" in front_text:
            print(f"Skipping audio for (already has sound): {front_text}")
            continue
        candidates.append((card_id, front_text, back_text))
    return candidates


def prepare_text_for_tts(text: str) -> str:
    """Strip HTML tags and collapse whitespace for cleaner TTS input."""
    without_tags = HTML_TAG_RE.sub(" ", text)
    return " ".join(without_tags.split())

def create_audio_file(
    client: OpenAI,
    text: str,
    filename: str,
    *,
    model: str,
    voice: str,
    instructions: str,
) -> None:
    """Generate speech audio for the supplied text and persist it to disk."""
    target_path = AUDIO_DIR / filename
    with client.audio.speech.with_streaming_response.create(
        model=model,
        voice=voice,
        input=text,
        instructions=instructions,
    ) as response:
        response.stream_to_file(target_path)


def process_card(
    card: Tuple[int, str, str],
    api_key: str,
    model: str,
    voice: str,
    instructions: str,
) -> Tuple[str, str, Any]:
    card_id, front_text, back_text = card
    local_client = OpenAI(api_key=api_key)
    filename = f"{card_id}.mp3"
    tts_input = prepare_text_for_tts(front_text)
    if not tts_input:
        return ("skip", front_text, "No speakable text after cleaning.")
    try:
        create_audio_file(
            local_client,
            tts_input,
            filename,
            model=model,
            voice=voice,
            instructions=instructions,
        )
        file_path = (AUDIO_DIR / filename).resolve()
        invoke(
            "updateNoteFields",
            note={
                "id": card_id,
                "fields": {"Front": front_text, "Back": back_text},
                "audio": [
                    {
                        "filename": filename,
                        "fields": ["Front"],
                        "path": file_path.as_posix(),
                    }
                ],
            },
        )
        return ("added", front_text, None)
    except Exception as exc:
        return ("error", front_text, exc)


def main() -> None:
    """
    Given a deck name, this script adds audio to all cards in that deck.
    The audio is generated by ChatGPT text to speech, and is added as a sound file to the front of the card.
    The filename of the sound file is the card id.
    """
    args = parse_args()
    api_key = load_api_key()

    print(f"Fetching notes for deck: {args.deck}")
    candidates = get_candidate_cards(args.deck)
    if not candidates:
        print(f"No cards eligible for audio generation in deck '{args.deck}'.")
        return

    worker_limit = max(1, args.workers)
    max_workers = max(1, min(worker_limit, len(candidates)))
    instructions = args.instructions.strip()
    print(
        f"Generating audio with up to {max_workers} worker(s) using model {args.model} and voice {args.voice}."
    )

    added = skipped = failed = 0
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = [
            executor.submit(
                process_card,
                card,
                api_key,
                args.model,
                args.voice,
                instructions,
            )
            for card in candidates
        ]
        for future in as_completed(futures):
            status, front_text, error = future.result()
            if status == "added":
                print(f"Adding audio for: {front_text}")
                added += 1
            elif status == "skip":
                print(f"Skipping audio for: {front_text} ({error})")
                skipped += 1
            else:
                print(f"Failed audio for: {front_text} ({error})")
                failed += 1

    print(f"Completed audio generation: {added} added, {skipped} skipped, {failed} failed.")


if __name__ == "__main__":
    main()
