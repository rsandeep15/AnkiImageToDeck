from concurrent.futures import ThreadPoolExecutor, as_completed
import os
from pathlib import Path
from openai import OpenAI
import sys

from AnkiSync import invoke

BASE_DIR = Path(__file__).resolve().parent
MEDIA_DIR = BASE_DIR / "media"
AUDIO_DIR = MEDIA_DIR / "audio"
AUDIO_DIR.mkdir(parents=True, exist_ok=True)
MAX_WORKERS = max(1, int(os.environ.get("ANKI_AUDIO_WORKERS", "10")))

def createAudioFile(client, text, fileName):
    """
    Generates an audio file using text-to-speech synthesis.

    This function utilizes the OpenAI client to convert the given text
    into speech and saves it as an audio file. The speech is generated
    using the "gpt-4o-mini-tts" model with the voice "onyx", and is
    instructed to speak like a native speaker.

    Args:
        client: An instance of the OpenAI client used to call the API.
        text (str): The text to be converted into speech.
        fileName (str): The name of the output audio file.
    """

    with client.audio.speech.with_streaming_response.create(
        model="gpt-4o-mini-tts",
        voice="onyx",
        input=text,
        instructions="Speak like a native speaker for the passed in language. Ignore anything in parenthesis",
    ) as response:
        response.stream_to_file(AUDIO_DIR / fileName)


def main():
    """
    Given a deck name, this script adds audio to all cards in that deck.
    The audio is generated by ChatGPT text to speech, and is added as a sound file to the front of the card.
    The filename of the sound file is the card id.
    """
    deckname = sys.argv[1]
    cards = invoke("findNotes", query="deck:{deck_name}".format(deck_name=deckname))

    if not cards:
        print("No cards found for deck:", deckname)
        return

    notes_info = invoke("notesInfo", notes=cards)

    candidates = []
    for cardID, note in zip(cards, notes_info):
        frontText = note['fields']['Front']['value']
        backText = note['fields']['Back']['value']
        if "[sound" in frontText:
            print("Skipping audio for (already has sound): " + frontText)
            continue
        candidates.append((cardID, frontText, backText))

    if not candidates:
        print("No cards eligible for audio generation.")
        return

    def process_card(cardID, frontText, backText):
        local_client = OpenAI()
        try:
            filename = str(cardID) + ".mp3"
            createAudioFile(local_client, frontText, filename)
            file_path = (AUDIO_DIR / filename).resolve()
            invoke("updateNoteFields", note={"id":cardID, "fields": {"Front":frontText, "Back":backText}, "audio": [{"filename":filename, "fields": ["Front"],"path":file_path.as_posix()}]})
            return ("added", frontText, None)
        except Exception as exc:
            return ("error", frontText, exc)

    with ThreadPoolExecutor(max_workers=min(MAX_WORKERS, len(candidates))) as executor:
        futures = [executor.submit(process_card, *candidate) for candidate in candidates]
        for future in as_completed(futures):
            status, frontText, error = future.result()
            if status == "added":
                print("Adding audio for: " + frontText)
            else:
                print("Failed audio for: {text} ({err})".format(text=frontText, err=error))
if __name__=="__main__":
    main()
